{% extends "theory/main.html" %}
{% load staticfiles %}

{% block doc %}
<div class="jumbotron">
    <div class="container">
    <h3 class="mb-3">Построение НКА по регулярному выражению</h3>
    <p>Рассмотрим алгоритм построения по регулярному выражению недетерминированного конечного автомата, допускающего тот же язык.</p>
    <p>Самым популярным алгоритмом для преобразования регулярных выражений в
        недетерминированные конечные автоматы является алгоритм Томпсона</p>
    </div>
</div>
<h5 class="mb-3">Алгоритм. Построение недетерминированного конечного автомата по регулярному выражению.</h5>
<p><i>Вход.</i> Регулярное выражение <span class="math inline">\(r\)</span> в алфавите <span class="math inline">\(T\)</span>.</p>

<p><i>Выход.</i> НКА <span class="math inline">\(N\)</span>, такой что <span class="math inline">\(L(N) = L(r)\)</span>.</p>

<p><i>Метод.</i> Автомат для выражения строится композицией из автоматов, соответствующих
подвыражениям. На каждом шаге построения строящийся автомат имеет в точности одно
заключительное состояние, в начальное состояние нет переходов из других состояний и нет
переходов из заключительного состояния в другие.</p>

<h5 class="mb-3 mt-5">Историческая справка</h5>
<p>В 1968 году американский программист Кен Томпсон, один из создателей Unix, обнаружил, что
    регулярные выражения весьма удобно использовать для задания шаблонов поиска строк в больших текстах.
    Регулярное выражение преобразуется в конечный автомат, который затем производит поиск строк, которые
    соответствуют шаблонам. Для преобразования регулярного выражения в конечный автомат, Томпсон
    придумал специальный алгоритм, который сейчас называется «построение Томпсона». Томпсон
    использовал механизм поиска по регулярным выражениям в текстовом редакторе, который разрабатывал, и
    с тех пор регулярные выражения стали стандартом для задания поисковых шаблонов.</p><p>
    Алгоритм работает рекурсивно, разделив рассматриваемое выражение на составляющие подвыражения, из
    которых затем будет построен НКА с определенным набором правил. Полученный из регулярного
    выражения автомат имеет следующие свойства:</p>
<ul>
    <li><p>Имеет только одно начальное состояние, которое не доступно из любого другого.</p></li>
    <li><p>Имеет ровно одно конечное состояние, которое не является доступным из любого другого.</p></li>
    <li><p>Число переходов, выходящих их любого состояния не более чем два.</p></li>
</ul>

<p>Так как НКА из определенного количества состояний, и в большинстве переходов из
    каждого состояния соответствует строке определенной длины за определенное время, НКА можно сделать
    по шаблону в линейное время, при условии фиксированного размера алфавита.</p>

<h5 class="mb-3 mt-5">Рассмотрим правила, применяемы в алгоритме Томпсона:</h5>

<p>1. Пустое выражение ε преобразуется в автомат вида:</p>

<img class="img-theory" id="graph_0" src="{% static 'media/graph_0.png' %}" alt="graph_0">

<p>2. Символ входного алфавита <span class="math inline">\((а)\)</span> отображается в автомате в виде:</p>

<img class="img-theory" id="graph_1" src="{% static 'media/graph_1.png' %}" alt="graph_1">

<p>3. Для выражения <span class="math inline">\(s|t\)</span> автомат <span class="math inline">\(N(s|t)\)</span> строится как показано на рисунке. Здесь q - новое
    начальное состояние и f - новое заключительное состояние. Заметим, что имеет место
    переход по ε из q в начальные состояния <span class="math inline">\(N(s)\)</span> и <span class="math inline">\(N(t)\)</span> и переход по ε из заключительных
    состояний <span class="math inline">\(N(s)\)</span> и <span class="math inline">\(N(t)\)</span> в f. Начальное и заключительное состояния автоматов <span class="math inline">\(N(s)\)</span> и <span class="math inline">\(N(t)\)</span> не
    являются таковыми для автомата <span class="math inline">\(N(s|t)\)</span>.</p>
<img class="img-theory" id="graph_2" src="{% static 'media/graph_2.png' %}" alt="graph_2">

<p>4. Для выражения <span class="math inline">\(st\)</span> автомат <span class="math inline">\(N(st)\)</span> строится следующим образом: начальное состояние <span class="math inline">\(N(s)\)</span>
    становится начальным для нового автомата, а заключительное состояние <span class="math inline">\(N(t)\)</span> становится
    заключительным для нового автомата. Начальное состояние <span class="math inline">\(N(t)\)</span> и заключительное
    состояние <span class="math inline">\(N(s)\)</span> сливаются, т.е. все переходы из начального состояния <span class="math inline">\(N(t)\)</span>s становятся
    переходами из заключительного состояния <span class="math inline">\(N(s)\)</span>. В новом автомате это объединенное
    состояние не является ни начальным, ни заключительным.</p>
<img class="img-theory" id="graph_3" src="{% static 'media/graph_3.png' %}" alt="graph_3">

<p>5. Для выражения <span class="math inline">\(s^*\)</span> автомат <span class="math inline">\(N(s^*)\)</span> строится следующим образом:</p>
<img class="img-theory" id="graph_4" src="{% static 'media/graph_4.png' %}" alt="graph_4">

<p>Здесь q - новое начальное состояние, а f - новое заключительное состояние.</p>

<p>Как было сказано выше, алгоритм Томпсона используется для задачи преобразования регулярных
    выражений в НКА. Несмотря на то, что алгоритм Томпсона был изобретен уже почти 50 лет назад, он не
    теряет своей актуальности и является самым известным алгоритмом преобразования регулярных выражений
    в НКА.
    </p>
<p class="mt-5"><i>*Источник: "Основы конструирования компиляторов" (В.А.Серебряков, М.П.Галочкин)</i></p>

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

{% load staticfiles %}
  <!-- <script src="{% static 'js/theory/regex_to_NFA.js' %}"></script> -->
  <script src="{% static 'js/viz.js/viz.js' %}"></script>
  <script src="{% static 'js/viz.js/full.render.js' %}"></script>
  <script>$('#regex_to_NFA').addClass('active');</script>

{% endblock %}